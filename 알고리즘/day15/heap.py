'''
힙
완전이진트리의 노드에서 키값이 가장 큰 노드나 가장 작은 노드 찾기위한 자료구조

최대힙:
완전이진트리
부모노드 키값 > 자식노드 키값
루트노드: 키값 가장 큰 노드


최소힙:
완전이진트리
부모키값<자식키값

루트노드: 키값 가장 작은 노드

'''


# heap 넣기 

def enq(n):
    global last
    last +=1 # 마지막 노드 추가(완전이진 트리 유지)
    h[last] = n #마지막 노드에 데이터 삽입

    # 부모>자식
    c = last
    p = c//2
    print(p,h[p],h[c])
    while p>=1 and h[p] < h[c]: # 부모 있는데 부모 번호가 더 작을경우
        h[p],h[c] = h[c], h[p]  # 교환
        c= p # 새로운 부모를 자식으로 해서
        p = c//2 # 다시 부모 찾기 , 부모 없으면(0) while 끝


N = 10# 노드수
h = [0] *(N+1) # 최대힙 , 노드 번호에 따른 값 저장할 것
last = 0 #마지막 노드번호

enq(2)
enq(5)
enq(3)
enq(6)
enq(4)

#heap 삭제

'''
힙에서는 루트 노드 원소만 삭제 가능, 삭제하고 반환 
힙 종류에 따라 최대/최소 구할수 잇음 


최대힙: key가 가장 큰값, 최소힙: key가 가장 작은 값 
'''
# 1. 루트노드의 키값 tmp에 잠깐 보관
#2. 마지막 노드 삭제
#3. 삽입노드를 루트에 가져옴
#4,원래 루트노드의 자식노드와 비교해서 값에 따라 자리 바꾸기 (max면 큰값이 부모 )


def deq():
    global last
    tmp = h[1] # 루트의 키값보관 장소
    h[1] = h[last]  # 루트와 자리 바꾸기
    last -=1 # 라스트 삭제
    p = 1 # 새로옮긴 수의 노드
    c = p*2 # 자식 노드
    while c<= last: # 자식이 있으면, c+1은 왼쪽 자식 번호
        if c+1 <= last and h[c]< h[c+1]: #오른쪽 자식이 더 크면
            c+=1
        if h[p] < h[c]: # 자식이 부모보다 더 크면
            h[p], h[c] = h[c], h[p] # 자리 교환
            p = c
            c = p*2
        else: #부모가 더 클경우 최대힙이라 멈추기
            break
    return tmp # 작업 끝났으면 보관 리턴

while(last>0):
    print(deq())

# 힙을 이용한 우선순위 큐 구현 가능
#




